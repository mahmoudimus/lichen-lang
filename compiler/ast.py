"""Python abstract syntax node definitions

This file was originally generated by Tools/compiler/astgen.py
"""
from compiler.consts import CO_VARARGS, CO_VARKEYWORDS

def flatten(seq):
    l = []
    for elt in seq:
        if isinstance(elt, (tuple, list)):
            for elt2 in flatten(elt):
                l.append(elt2)
        else:
            l.append(elt)
    return l

def flatten_nodes(seq):
    return [n for n in flatten(seq) if isinstance(n, Node)]

def flatten_statement(seq):
    l = []
    for elt in seq:
        if isinstance(elt, Stmt):
            l += flatten_statement(elt)
        else:
            l.append(elt)
    return l

def flatten_assignment(node):
    l = []
    if isinstance(node, (AssList, AssTuple)):
        for n in node.nodes:
            l += flatten_assignment(n)
    else:
        l.append(node)
    return l

def is_deletion(node):
    return isinstance(node, (AssAttr, AssName)) and node.flags == "OP_DELETE"

def docstring(s):
    if s.find("\n") != -1:
        if s.find("'''") != -1:
            return '"""%s"""' % s.replace('"""', '\\"\\"\\"')
        else:
            return "'''%s'''" % s.replace("'''", "\\'\\'\\'")
    else:
        return repr(s)

def indent(s):
    return s.replace("\n", "\n\t")

def get_defaults(node):

    "Return a list of (argument name, default) tuples for the 'node'."

    star = (node.flags & 4 != 0) and 1 or 0
    dstar = (node.flags & 8 != 0) and 1 or 0
    argnames = node.argnames[:]

    # Add stars to star and dstar parameters.

    if star:
        argnames[-dstar-star] = "*%s" % argnames[-dstar-star]
    if dstar:
        argnames[-dstar] = "**%s" % argnames[-dstar]

    # Map defaults to parameters.

    defaults = [None] * (len(node.argnames) - star - dstar - len(node.defaults)) + list(node.defaults) + [None] * (star + dstar)
    return zip(argnames, defaults)

def decode_function(node):
    return [(default and "%s=%s" % (argname, default) or argname) for (argname, default) in get_defaults(node)]

nodes = {}

class OperatorUser:

    "Operator-related node."

    pass

class Operator(OperatorUser):

    "Operator node."

    pass

class Node:

    "Abstract base class for ast nodes."

    def getChildren(self):
        pass # implemented by subclasses

    def __iter__(self):
        for n in self.getChildren():
            yield n

    def getChildNodes(self):
        pass # implemented by subclasses

class EmptyNode(Node):
    pass

class Expression(Node):
    # Expression is an artificial node class to support "eval"
    nodes["expression"] = "Expression"
    def __init__(self, node):
        self.node = node

    def getChildren(self):
        return self.node,

    def getChildNodes(self):
        return self.node,

    def __repr__(self):
        return "Expression(%r)" % (self.node,)

    def __str__(self):
        return str(self.node)

class Add(Node, Operator):
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

    def __repr__(self):
        return "Add((%r, %r))" % (self.left, self.right)

    def __str__(self):
        return "(%s + %s)" % (self.left, self.right)

class And(Node):
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

    def __repr__(self):
        return "And(%r)" % (self.nodes,)

    def __str__(self):
        return "(%s)" % " and ".join(map(str, self.nodes))

class AssAttr(Node):
    def __init__(self, expr, attrname, flags, lineno=None):
        self.expr = expr
        self.attrname = attrname
        self.flags = flags
        self.lineno = lineno

    def getChildren(self):
        return self.expr, self.attrname, self.flags

    def getChildNodes(self):
        return self.expr,

    def __repr__(self):
        return "AssAttr(%r, %r, %r)" % (self.expr, self.attrname, self.flags)

    def __str__(self):
        return "%s%s.%s" % (self.flags == "OP_DELETE" and "del " or "", self.expr, self.attrname)

class AssList(Node):
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

    def __repr__(self):
        return "AssList(%r)" % (self.nodes,)

    def __str__(self):
        nodes = flatten_assignment(self)
        if nodes and is_deletion(nodes[0]):
            return "; ".join(map(str, self.nodes))
        else:
            return "[%s]" % ", ".join(map(str, self.nodes))

class AssName(Node):
    def __init__(self, name, flags, lineno=None):
        self.name = name
        self.flags = flags
        self.lineno = lineno

    def getChildren(self):
        return self.name, self.flags

    def getChildNodes(self):
        return ()

    def __repr__(self):
        return "AssName(%r, %r)" % (self.name, self.flags)

    def __str__(self):
        return "%s%s" % (self.flags == "OP_DELETE" and "del " or "", self.name)

class AssTuple(Node):
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

    def __repr__(self):
        return "AssTuple(%r)" % (self.nodes,)

    def __str__(self):
        nodes = flatten_assignment(self)
        if nodes and is_deletion(nodes[0]):
            return "; ".join(map(str, self.nodes))
        else:
            return "(%s)" % ", ".join(map(str, self.nodes))

class Assert(Node):
    def __init__(self, test, fail, lineno=None):
        self.test = test
        self.fail = fail
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.test)
        children.append(self.fail)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.test)
        if self.fail is not None:
            nodelist.append(self.fail)
        return tuple(nodelist)

    def __repr__(self):
        return "Assert(%r, %r)" % (self.test, self.fail)

    def __str__(self):
        return "assert %s%s" % (self.test, self.fail and ", %s" % self.fail or "")

class Assign(Node):
    def __init__(self, nodes, expr, lineno=None):
        self.nodes = nodes
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.extend(flatten(self.nodes))
        children.append(self.expr)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        nodelist.append(self.expr)
        return tuple(nodelist)

    def __repr__(self):
        return "Assign(%r, %r)" % (self.nodes, self.expr)

    def __str__(self):
        return "%s = %s" % (", ".join(map(str, self.nodes)), self.expr)

class AugAssign(Node, OperatorUser):
    def __init__(self, node, op, expr, lineno=None):
        self.node = node
        self.op = op
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        return self.node, self.op, self.expr

    def getChildNodes(self):
        return self.node, self.expr

    def __repr__(self):
        return "AugAssign(%r, %r, %r)" % (self.node, self.op, self.expr)

    def __str__(self):
        return "%s %s %s" % (self.node, self.op, self.expr)

class Backquote(Node):
    def __init__(self, expr, lineno=None):
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return self.expr,

    def __repr__(self):
        return "Backquote(%r)" % (self.expr,)

    def __str__(self):
        return "`%s`" % self.expr

class Bitand(Node, Operator):
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

    def __repr__(self):
        return "Bitand(%r)" % (self.nodes,)

    def __str__(self):
        return "(%s)" % " & ".join(map(str, self.nodes))

class Bitor(Node, Operator):
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

    def __repr__(self):
        return "Bitor(%r)" % (self.nodes,)

    def __str__(self):
        return "(%s)" % " | ".join(map(str, self.nodes))

class Bitxor(Node, Operator):
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

    def __repr__(self):
        return "Bitxor(%r)" % (self.nodes,)

    def __str__(self):
        return "(%s)" % " ^ ".join(map(str, self.nodes))

class Break(Node):
    def __init__(self, lineno=None):
        self.lineno = lineno

    def getChildren(self):
        return ()

    def getChildNodes(self):
        return ()

    def __repr__(self):
        return "Break()"

    def __str__(self):
        return "break"

class CallFunc(Node):
    def __init__(self, node, args, star_args = None, dstar_args = None, lineno=None):
        self.node = node
        self.args = args
        self.star_args = star_args
        self.dstar_args = dstar_args
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.node)
        children.extend(flatten(self.args))
        children.append(self.star_args)
        children.append(self.dstar_args)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.node)
        nodelist.extend(flatten_nodes(self.args))
        if self.star_args is not None:
            nodelist.append(self.star_args)
        if self.dstar_args is not None:
            nodelist.append(self.dstar_args)
        return tuple(nodelist)

    def __repr__(self):
        args = []
        if self.dstar_args:
            args.insert(0, repr(self.dstar_args))
        if args or self.star_args:
            args.insert(0, repr(self.star_args))
        return "CallFunc(%r, %r%s)" % (self.node, self.args, args and (", %s" % ", ".join(args)) or "")

    def __str__(self):
        star_args = self.star_args and ["*%s" % self.star_args] or []
        dstar_args = self.dstar_args and ["**%s" % self.dstar_args] or []
        return "%s(%s)" % (self.node, ", ".join(map(str, tuple(self.args) + tuple(star_args) + tuple(dstar_args))))

class Class(Node):
    def __init__(self, name, bases, doc, code, decorators = None, lineno=None):
        self.name = name
        self.bases = bases
        self.doc = doc
        self.code = code
        self.decorators = decorators
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.name)
        children.extend(flatten(self.bases))
        children.append(self.doc)
        children.append(self.code)
        children.append(self.decorators)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.bases))
        nodelist.append(self.code)
        if self.decorators is not None:
            nodelist.append(self.decorators)
        return tuple(nodelist)

    def __repr__(self):
        return "Class(%r, %r, %r, %r, %r)" % (self.name, self.bases, self.doc, self.code, self.decorators)

    def __str__(self):
        return "%sclass %s%s:%s%s\n" % (
            self.decorators and "%s\n" % "\n".join([("@%s" % decorator) for decorator in self.decorators]) or "",
            self.name,
            self.bases and "(%s)" % ", ".join(map(str, self.bases)) or "",
            self.doc and "\n\t" + docstring(self.doc) or "",
            indent("\n%s" % self.code)
            )

class Compare(Node, OperatorUser):
    def __init__(self, expr, ops, lineno=None):
        self.expr = expr
        self.ops = ops
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.extend(flatten(self.ops))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(flatten_nodes(self.ops))
        return tuple(nodelist)

    def __repr__(self):
        return "Compare(%r, %r)" % (self.expr, self.ops)

    def __str__(self):
        return "%s %s" % (self.expr, " ".join([("%s %s" % op) for op in self.ops]))

class Const(Node):
    def __init__(self, value, literal=None, lineno=None):
        self.value = value
        self.literal = literal
        self.lineno = lineno

    def getChildren(self):
        return self.value,

    def getChildNodes(self):
        return ()

    def __repr__(self):
        return "Const(%r, %r)" % (self.value, self.literal)

    def __str__(self):
        return repr(self.value)

class Continue(Node):
    def __init__(self, lineno=None):
        self.lineno = lineno

    def getChildren(self):
        return ()

    def getChildNodes(self):
        return ()

    def __repr__(self):
        return "Continue()"

    def __str__(self):
        return "continue"

class Decorators(Node):
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

    def __repr__(self):
        return "Decorators(%r)" % (self.nodes,)

    def __str__(self):
        return "\n".join([("@%s" % node) for node in self.nodes])

class Dict(Node):
    def __init__(self, items, lineno=None):
        self.items = items
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.items))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.items))
        return tuple(nodelist)

    def __repr__(self):
        return "Dict(%r)" % (self.items,)

    def __str__(self):
        return "{%s}" % ", ".join([("%s : %s" % (key, value)) for (key, value) in self.items])

class Discard(Node):
    def __init__(self, expr, lineno=None):
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return self.expr,

    def __repr__(self):
        return "Discard(%r)" % (self.expr,)

    def __str__(self):
        return str(self.expr)

class Div(Node, Operator):
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

    def __repr__(self):
        return "Div((%r, %r))" % (self.left, self.right)

    def __str__(self):
        return "(%s / %s)" % (self.left, self.right)

class Ellipsis(Node):
    def __init__(self, lineno=None):
        self.lineno = lineno

    def getChildren(self):
        return ()

    def getChildNodes(self):
        return ()

    def __repr__(self):
        return "Ellipsis()"

    def __str__(self):
        return "..."

class Exec(Node):
    def __init__(self, expr, locals, globals, lineno=None):
        self.expr = expr
        self.locals = locals
        self.globals = globals
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.append(self.locals)
        children.append(self.globals)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        if self.locals is not None:
            nodelist.append(self.locals)
        if self.globals is not None:
            nodelist.append(self.globals)
        return tuple(nodelist)

    def __repr__(self):
        return "Exec(%r, %r, %r)" % (self.expr, self.locals, self.globals)

    def __str__(self):
        return "exec %s%s%s" % (self.expr, self.locals and "in %s" % self.locals or "",
            self.globals and ", %s" % self.globals or "")

class FloorDiv(Node, Operator):
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

    def __repr__(self):
        return "FloorDiv((%r, %r))" % (self.left, self.right)

    def __str__(self):
        return "(%s // %s)" % (self.left, self.right)

class For(Node):
    def __init__(self, assign, list, body, else_, lineno=None):
        self.assign = assign
        self.list = list
        self.body = body
        self.else_ = else_
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.assign)
        children.append(self.list)
        children.append(self.body)
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.assign)
        nodelist.append(self.list)
        nodelist.append(self.body)
        if self.else_ is not None:
            nodelist.append(self.else_)
        return tuple(nodelist)

    def __repr__(self):
        return "For(%r, %r, %r, %r)" % (self.assign, self.list, self.body, self.else_)

    def __str__(self):
        return "for %s in %s:%s%s" % (
            self.assign, self.list,
            indent("\n%s" % self.body),
            self.else_ and "\nelse:%s" % indent("\n%s" % self.else_) or ""
            )

class From(Node):
    def __init__(self, modname, names, level, lineno=None):
        self.modname = modname
        self.names = names
        self.level = level
        self.lineno = lineno

    def getChildren(self):
        return self.modname, self.names, self.level

    def getChildNodes(self):
        return ()

    def __repr__(self):
        return "From(%r, %r, %r)" % (self.modname, self.names, self.level)

    def __str__(self):
        return "from %s import %s" % (self.modname,
            ", ".join([(alias and "%s as %s" % (name, alias) or name) for (name, alias) in self.names]))

class Function(Node):
    def __init__(self, decorators, name, argnames, defaults, flags, doc, code, lineno=None):
        self.decorators = decorators
        self.name = name
        self.argnames = argnames
        self.defaults = defaults
        self.flags = flags
        self.doc = doc
        self.code = code
        self.lineno = lineno
        self.varargs = self.kwargs = None
        if flags & CO_VARARGS:
            self.varargs = 1
        if flags & CO_VARKEYWORDS:
            self.kwargs = 1

    def getChildren(self):
        children = []
        children.append(self.decorators)
        children.append(self.name)
        children.append(self.argnames)
        children.extend(flatten(self.defaults))
        children.append(self.flags)
        children.append(self.doc)
        children.append(self.code)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        if self.decorators is not None:
            nodelist.append(self.decorators)
        nodelist.extend(flatten_nodes(self.defaults))
        nodelist.append(self.code)
        return tuple(nodelist)

    def __repr__(self):
        return "Function(%r, %r, %r, %r, %r, %r, %r)" % (self.decorators, self.name, self.argnames, self.defaults, self.flags, self.doc, self.code)

    def __str__(self):
        parameters = decode_function(self)

        return "%sdef %s(%s):%s%s\n" % (
            self.decorators and "%s\n" % "\n".join([("@%s" % decorator) for decorator in self.decorators]) or "",
            self.name,
            ", ".join(parameters),
            self.doc and "\n\n\t%s\n" % docstring(self.doc) or "",
            indent("\n%s" % self.code)
            )

class GenExpr(Node):
    def __init__(self, code, lineno=None):
        self.code = code
        self.lineno = lineno
        self.argnames = ['.0']
        self.varargs = self.kwargs = None

    def getChildren(self):
        return self.code,

    def getChildNodes(self):
        return self.code,

    def __repr__(self):
        return "GenExpr(%r)" % (self.code,)

    def __str__(self):
        return str(self.code)

class GenExprFor(Node):
    def __init__(self, assign, iter, ifs, lineno=None):
        self.assign = assign
        self.iter = iter
        self.ifs = ifs
        self.lineno = lineno
        self.is_outmost = False

    def getChildren(self):
        children = []
        children.append(self.assign)
        children.append(self.iter)
        children.extend(flatten(self.ifs))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.assign)
        nodelist.append(self.iter)
        nodelist.extend(flatten_nodes(self.ifs))
        return tuple(nodelist)

    def __repr__(self):
        return "GenExprFor(%r, %r, %r)" % (self.assign, self.iter, self.ifs)

    def __str__(self):
        return "for %s in %s%s" % (
            self.assign, self.iter,
            self.ifs and " ".join(map(str, self.ifs)) or ""
            )

class GenExprIf(Node):
    def __init__(self, test, lineno=None):
        self.test = test
        self.lineno = lineno

    def getChildren(self):
        return self.test,

    def getChildNodes(self):
        return self.test,

    def __repr__(self):
        return "GenExprIf(%r)" % (self.test,)

    def __str__(self):
        return "if %s" % self.test

class GenExprInner(Node):
    def __init__(self, expr, quals, lineno=None):
        self.expr = expr
        self.quals = quals
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.extend(flatten(self.quals))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(flatten_nodes(self.quals))
        return tuple(nodelist)

    def __repr__(self):
        return "GenExprInner(%r, %r)" % (self.expr, self.quals)

    def __str__(self):
        return "%s %s" % (self.expr, " ".join(map(str, self.quals)))

class Getattr(Node):
    def __init__(self, expr, attrname, lineno=None):
        self.expr = expr
        self.attrname = attrname
        self.lineno = lineno

    def getChildren(self):
        return self.expr, self.attrname

    def getChildNodes(self):
        return self.expr,

    def __repr__(self):
        return "Getattr(%r, %r)" % (self.expr, self.attrname)

    def __str__(self):
        return "%s.%s" % (self.expr, self.attrname)

class Global(Node):
    def __init__(self, names, lineno=None):
        self.names = names
        self.lineno = lineno

    def getChildren(self):
        return self.names,

    def getChildNodes(self):
        return ()

    def __repr__(self):
        return "Global(%r)" % (self.names,)

    def __str__(self):
        return "global %s" % ", ".join(map(str, self.names))

class If(Node):
    def __init__(self, tests, else_, lineno=None):
        self.tests = tests
        self.else_ = else_
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.extend(flatten(self.tests))
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.tests))
        if self.else_ is not None:
            nodelist.append(self.else_)
        return tuple(nodelist)

    def __repr__(self):
        return "If(%r, %r)" % (self.tests, self.else_)

    def __str__(self):
        tests = [("%sif %s:%s" % (i > 0 and "el" or "", test, indent("\n%s" % body))) for (i, (test, body)) in enumerate(self.tests)]
        return "%s%s" % (
            "\n".join(tests),
            self.else_ and "\nelse:%s" % indent("\n%s" % self.else_) or ""
            )

class Import(Node):
    def __init__(self, names, lineno=None):
        self.names = names
        self.lineno = lineno

    def getChildren(self):
        return self.names,

    def getChildNodes(self):
        return ()

    def __repr__(self):
        return "Import(%r)" % (self.names,)

    def __str__(self):
        return "import %s" % (
            ", ".join([(alias and "%s as %s" % (name, alias) or name) for (name, alias) in self.names]))

class Invert(Node, Operator):
    def __init__(self, expr, lineno=None):
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return self.expr,

    def __repr__(self):
        return "Invert(%r)" % (self.expr,)

    def __str__(self):
        return "~%s" % self.expr

class Keyword(Node):
    def __init__(self, name, expr, lineno=None):
        self.name = name
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        return self.name, self.expr

    def getChildNodes(self):
        return self.expr,

    def __repr__(self):
        return "Keyword(%r, %r)" % (self.name, self.expr)

    def __str__(self):
        return "%s=%s" % (self.name, self.expr)

class Lambda(Node):
    def __init__(self, argnames, defaults, flags, code, lineno=None):
        self.argnames = argnames
        self.defaults = defaults
        self.flags = flags
        self.code = code
        self.lineno = lineno
        self.varargs = self.kwargs = None
        if flags & CO_VARARGS:
            self.varargs = 1
        if flags & CO_VARKEYWORDS:
            self.kwargs = 1

    def getChildren(self):
        children = []
        children.append(self.argnames)
        children.extend(flatten(self.defaults))
        children.append(self.flags)
        children.append(self.code)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.defaults))
        nodelist.append(self.code)
        return tuple(nodelist)

    def __repr__(self):
        return "Lambda(%r, %r, %r, %r)" % (self.argnames, self.defaults, self.flags, self.code)

    def __str__(self):
        parameters = decode_function(self)
        return "lambda %s: %s" % (", ".join(parameters), self.code)

class LeftShift(Node, Operator):
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

    def __repr__(self):
        return "LeftShift((%r, %r))" % (self.left, self.right)

    def __str__(self):
        return "(%s << %s)" % (self.left, self.right)

class List(Node):
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

    def __repr__(self):
        return "List(%r)" % (self.nodes,)

    def __str__(self):
        return "[%s]" % ", ".join(map(str, self.nodes))

class Mod(Node, Operator):
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

    def __repr__(self):
        return "Mod((%r, %r))" % (self.left, self.right)

    def __str__(self):
        return "(%s %% %s)" % (self.left, self.right)

class Module(Node):
    def __init__(self, doc, node, lineno=None):
        self.doc = doc
        self.node = node
        self.lineno = lineno

    def getChildren(self):
        return self.doc, self.node

    def getChildNodes(self):
        return self.node,

    def __repr__(self):
        return "Module(%r, %r)" % (self.doc, self.node)

    def __str__(self):
        return "%s%s" % (self.doc and "%s\n\n" % docstring(self.doc) or "", self.node)

class Mul(Node, Operator):
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

    def __repr__(self):
        return "Mul((%r, %r))" % (self.left, self.right)

    def __str__(self):
        return "(%s * %s)" % (self.left, self.right)

class Name(Node):
    def __init__(self, name, lineno=None):
        self.name = name
        self.lineno = lineno

    def getChildren(self):
        return self.name,

    def getChildNodes(self):
        return ()

    def __repr__(self):
        return "Name(%r)" % (self.name,)

    def __str__(self):
        return str(self.name)

class Not(Node):
    def __init__(self, expr, lineno=None):
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return self.expr,

    def __repr__(self):
        return "Not(%r)" % (self.expr,)

    def __str__(self):
        return "not %s" % self.expr

class Or(Node):
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

    def __repr__(self):
        return "Or(%r)" % (self.nodes,)

    def __str__(self):
        return "(%s)" % " or ".join(map(str, self.nodes))

class Pass(Node):
    def __init__(self, lineno=None):
        self.lineno = lineno

    def getChildren(self):
        return ()

    def getChildNodes(self):
        return ()

    def __repr__(self):
        return "Pass()"

    def __str__(self):
        return "pass"

class Power(Node, Operator):
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

    def __repr__(self):
        return "Power((%r, %r))" % (self.left, self.right)

    def __str__(self):
        return "(%s ** %s)" % (self.left, self.right)

class Print(Node):
    def __init__(self, nodes, dest, lineno=None):
        self.nodes = nodes
        self.dest = dest
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.extend(flatten(self.nodes))
        children.append(self.dest)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        if self.dest is not None:
            nodelist.append(self.dest)
        return tuple(nodelist)

    def __repr__(self):
        return "Print(%r, %r)" % (self.nodes, self.dest)

    def __str__(self):
        dest = self.dest and [">>%s" % self.dest] or []
        return "print %s," % ", ".join(map(str, dest + self.nodes))

class Printnl(Node):
    def __init__(self, nodes, dest, lineno=None):
        self.nodes = nodes
        self.dest = dest
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.extend(flatten(self.nodes))
        children.append(self.dest)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        if self.dest is not None:
            nodelist.append(self.dest)
        return tuple(nodelist)

    def __repr__(self):
        return "Printnl(%r, %r)" % (self.nodes, self.dest)

    def __str__(self):
        dest = self.dest and [">>%s" % self.dest] or []
        return "print %s" % ", ".join(map(str, dest + self.nodes))

class Raise(Node):
    def __init__(self, expr1, expr2, expr3, lineno=None):
        self.expr1 = expr1
        self.expr2 = expr2
        self.expr3 = expr3
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.expr1)
        children.append(self.expr2)
        children.append(self.expr3)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        if self.expr1 is not None:
            nodelist.append(self.expr1)
        if self.expr2 is not None:
            nodelist.append(self.expr2)
        if self.expr3 is not None:
            nodelist.append(self.expr3)
        return tuple(nodelist)

    def __repr__(self):
        return "Raise(%r, %r, %r)" % (self.expr1, self.expr2, self.expr3)

    def __str__(self):
        args = self.expr1 and [self.expr1] or []
        args += self.expr2 and [self.expr2] or []
        args += self.expr3 and [self.expr3] or []
        return "raise %s" % ", ".join(map(str, args))

class Return(Node):
    def __init__(self, value, lineno=None):
        self.value = value
        self.lineno = lineno

    def getChildren(self):
        return self.value,

    def getChildNodes(self):
        return self.value,

    def __repr__(self):
        return "Return(%r)" % (self.value,)

    def __str__(self):
        return "return %s" % self.value

class RightShift(Node, Operator):
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

    def __repr__(self):
        return "RightShift((%r, %r))" % (self.left, self.right)

    def __str__(self):
        return "(%s >> %s)" % (self.left, self.right)

class Set(Node):
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

    def __repr__(self):
        return "Set(%r)" % (self.nodes,)

    def __str__(self):
        return "{%s}" % ", ".join(map(str, self.nodes))

class Slice(Node, OperatorUser):
    def __init__(self, expr, flags, lower, upper, lineno=None):
        self.expr = expr
        self.flags = flags
        self.lower = lower
        self.upper = upper
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.append(self.flags)
        children.append(self.lower)
        children.append(self.upper)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        if self.lower is not None:
            nodelist.append(self.lower)
        if self.upper is not None:
            nodelist.append(self.upper)
        return tuple(nodelist)

    def __repr__(self):
        return "Slice(%r, %r, %r, %r)" % (self.expr, self.flags, self.lower, self.upper)

    def __str__(self):
        args = [self.lower or "", self.upper or ""]
        return "%s%s[%s]" % (self.flags == "OP_DELETE" and "del " or "", self.expr, ":".join(map(str, args)))

class Sliceobj(Node):
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

    def __repr__(self):
        return "Sliceobj(%r)" % (self.nodes,)

    def __str__(self):
        return ":".join(map(str, self.nodes))

class Stmt(Node):
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

    def __repr__(self):
        return "Stmt(%r)" % (self.nodes,)

    def __str__(self):
        return "\n".join(map(str, flatten_statement(self.nodes)))

class Sub(Node, Operator):
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

    def __repr__(self):
        return "Sub((%r, %r))" % (self.left, self.right)

    def __str__(self):
        return "(%s - %s)" % (self.left, self.right)

class Subscript(Node, OperatorUser):
    def __init__(self, expr, flags, subs, lineno=None):
        self.expr = expr
        self.flags = flags
        self.subs = subs
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.append(self.flags)
        children.extend(flatten(self.subs))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(flatten_nodes(self.subs))
        return tuple(nodelist)

    def __repr__(self):
        return "Subscript(%r, %r, %r)" % (self.expr, self.flags, self.subs)

    def __str__(self):
        return "%s%s[%s]" % (self.flags == "OP_DELETE" and "del " or "", self.expr, ",".join(map(str, self.subs)))

class TryExcept(Node):
    def __init__(self, body, handlers, else_, lineno=None):
        self.body = body
        self.handlers = handlers
        self.else_ = else_
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.body)
        children.extend(flatten(self.handlers))
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.body)
        nodelist.extend(flatten_nodes(self.handlers))
        if self.else_ is not None:
            nodelist.append(self.else_)
        return tuple(nodelist)

    def __repr__(self):
        return "TryExcept(%r, %r, %r)" % (self.body, self.handlers, self.else_)

    def __str__(self):
        handlers = [
            ("\nexcept%s%s:%s" % (spec and " %s" % spec or "", assign and ", %s" % assign or "", indent("\n%s" % statement)))
            for (spec, assign, statement) in self.handlers
            ]

        return "try:%s%s%s" % (
            indent("\n%s" % self.body),
            "".join(handlers),
            self.else_ and "\nelse:%s" % indent("\n%s" % self.else_) or ""
            )

class TryFinally(Node):
    def __init__(self, body, final, lineno=None):
        self.body = body
        self.final = final
        self.lineno = lineno

    def getChildren(self):
        return self.body, self.final

    def getChildNodes(self):
        return self.body, self.final

    def __repr__(self):
        return "TryFinally(%r, %r)" % (self.body, self.final)

    def __str__(self):
        return "try:%s\nfinally:%s" % (
            indent("\n%s" % self.body),
            indent("\n%s" % self.final)
            )

class Tuple(Node):
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

    def __repr__(self):
        return "Tuple(%r)" % (self.nodes,)

    def __str__(self):
        return "(%s)" % ", ".join(map(str, self.nodes))

class UnaryAdd(Node, Operator):
    def __init__(self, expr, lineno=None):
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return self.expr,

    def __repr__(self):
        return "UnaryAdd(%r)" % (self.expr,)

    def __str__(self):
        return "+%s" % self.expr

class UnarySub(Node, Operator):
    def __init__(self, expr, lineno=None):
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return self.expr,

    def __repr__(self):
        return "UnarySub(%r)" % (self.expr,)

    def __str__(self):
        return "-%s" % self.expr

class While(Node):
    def __init__(self, test, body, else_, lineno=None):
        self.test = test
        self.body = body
        self.else_ = else_
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.test)
        children.append(self.body)
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.test)
        nodelist.append(self.body)
        if self.else_ is not None:
            nodelist.append(self.else_)
        return tuple(nodelist)

    def __repr__(self):
        return "While(%r, %r, %r)" % (self.test, self.body, self.else_)

    def __str__(self):
        return "while %s:%s%s" % (
            self.test,
            indent("\n%s" % self.body),
            self.else_ and "\nelse:%s" % indent("\n%s" % self.else_) or ""
            )

class With(Node):
    def __init__(self, expr, vars, body, lineno=None):
        self.expr = expr
        self.vars = vars
        self.body = body
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.append(self.vars)
        children.append(self.body)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        if self.vars is not None:
            nodelist.append(self.vars)
        nodelist.append(self.body)
        return tuple(nodelist)

    def __repr__(self):
        return "With(%r, %r, %r)" % (self.expr, self.vars, self.body)

    def __str__(self):
        return "with %s%s:%s" % (
            self.expr,
            self.vars and " as %s" % ", ".join(map(str, self.vars)),
            indent("\n%s" % self.body),
            )

for name, obj in globals().items():
    if isinstance(obj, type) and issubclass(obj, Node):
        nodes[name.lower()] = obj
