#!/usr/bin/env python

from errors import *
from os import rename
from os.path import abspath, exists, join, split
from pyparser import error
from subprocess import Popen, PIPE
from time import time
import importer, deducer, optimiser, generator, translator
import sys

libdirs = [
    join(split(__file__)[0], "lib"),
    "/usr/share/lichen/lib"
    ]

def load_module(filename, module_name):
    for libdir in libdirs:
        path = join(libdir, filename)
        if exists(path):
            return i.load_from_file(path, module_name)
    return None

def show_missing(missing):
    missing = list(missing)
    missing.sort()
    for module_name, name in missing:
        print >>sys.stderr, "Module %s references an unknown object: %s" % (module_name, name)

def show_syntax_error(exc):
    print >>sys.stderr, "Syntax error at column %d on line %d in file %s:" % (exc.offset, exc.lineno, exc.filename)
    print >>sys.stderr
    print >>sys.stderr, exc.text.rstrip()
    print >>sys.stderr, " " * exc.offset + "^"

def stopwatch(activity, now):
    print >>sys.stderr, "%s took %.2f seconds" % (activity, time() - now)
    return time()

def call(tokens, verbose=False):
    out = not verbose and PIPE or None
    cmd = Popen(tokens, stdout=out, stderr=out)
    stdout, stderr = cmd.communicate()
    return cmd.wait()

# Main program.

if __name__ == "__main__":
    args = sys.argv[1:]
    path = libdirs

    # Determine the options and arguments.

    debug = False
    make = True
    make_verbose = True
    reset = False
    traceback = False
    verbose = False

    filenames = []
    outputs = []

    # Obtain program filenames by default.

    l = filenames

    for arg in args:
        if arg == "-c": make = False
        elif arg == "-g": debug = True
        elif arg == "-q": make_verbose = False
        elif arg == "-r": reset = True
        elif arg == "-tb": traceback = True
        elif arg == "-o": l = outputs
        elif arg == "-v": verbose = True
        else:
            l.append(arg)

            # Revert to collecting program filenames after obtaining the output
            # executable filename.

            if l is outputs: l = filenames

    # Obtain the program filename.

    if len(filenames) > 1:
        print >>sys.stderr, "Only one main program file can be specified."
        sys.exit(1)

    filename = abspath(filenames[0])
    path.append(split(filename)[0])

    # Obtain the output filename.

    output = outputs and outputs[0] or "_main"

    # Define the output data directories.

    datadir = "_lplc"
    cache_dir = join(datadir, "_cache")
    deduced_dir = join(datadir, "_deduced")
    output_dir = join(datadir, "_output")
    generated_dir = join(datadir, "_generated")

    # Load the program.

    try:
        start = now = time()

        i = importer.Importer(path, cache_dir, verbose)
        m = i.initialise(filename, reset)
        success = i.finalise()

        now = stopwatch("Inspection", now)

        # Check for success, indicating missing references otherwise.

        if not success:
            show_missing(i.missing)
            sys.exit(1)

        d = deducer.Deducer(i, deduced_dir)
        d.to_output()

        now = stopwatch("Deduction", now)

        o = optimiser.Optimiser(i, d, output_dir)
        o.to_output()

        now = stopwatch("Optimisation", now)

        g = generator.Generator(i, o, generated_dir)
        g.to_output(debug)

        now = stopwatch("Generation", now)

        t = translator.Translator(i, d, o, generated_dir)
        t.to_output()

        now = stopwatch("Translation", now)

        # Compile the program unless otherwise indicated.

        if make:
            make_clean_cmd = ["make", "-C", generated_dir, "clean"]
            make_cmd = make_clean_cmd[:-1]

            retval = call(make_clean_cmd, make_verbose)
            if not retval:
                retval = call(make_cmd, make_verbose)

            if not retval:
                stopwatch("Compilation", now)
            else:
                sys.exit(retval)

            # Move the executable into the current directory.

            rename(join(generated_dir, "main"), output)

    # Report any errors.

    except error.SyntaxError, exc:
        show_syntax_error(exc)
        if traceback:
            raise
        sys.exit(1)

    except ProcessingError, exc:
        print exc
        if traceback:
            raise
        sys.exit(1)

    else:
        sys.exit(0)

# vim: tabstop=4 expandtab shiftwidth=4
