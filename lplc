#!/usr/bin/env python

from errors import *
from os import rename
from os.path import abspath, exists, join, split
from pyparser import error
from subprocess import Popen, PIPE
from time import time
import importer, deducer, optimiser, generator, translator
import sys

libdirs = [
    join(split(__file__)[0], "lib"),
    "/usr/share/lichen/lib"
    ]

def load_module(filename, module_name):
    for libdir in libdirs:
        path = join(libdir, filename)
        if exists(path):
            return i.load_from_file(path, module_name)
    return None

def show_missing(missing):
    missing = list(missing)
    missing.sort()
    for module_name, name in missing:
        print >>sys.stderr, "Module %s references an unknown object: %s" % (module_name, name)

def show_syntax_error(exc):
    print >>sys.stderr, "Syntax error at column %d on line %d in file %s:" % (exc.offset, exc.lineno, exc.filename)
    print >>sys.stderr
    print >>sys.stderr, exc.text.rstrip()
    print >>sys.stderr, " " * exc.offset + "^"

def stopwatch(activity, now):
    print >>sys.stderr, "%s took %.2f seconds" % (activity, time() - now)
    return time()

def call(tokens, verbose=False):
    out = not verbose and PIPE or None
    cmd = Popen(tokens, stdout=out, stderr=out)
    stdout, stderr = cmd.communicate()
    return cmd.wait()

def start_arg_list(l, arg, prefix, needed):

    """
    Add to 'l' any value given as part of 'arg' having the given option
    'prefix'. The 'needed' number of values is provided in case no value is
    found.

    Return 'l' and 'needed' decremented by 1 together in a tuple.
    """

    s = arg[len(prefix):].strip()
    if s:
        l.append(s)
        return l, needed - 1
    else:
        return l, needed

# Main program.

if __name__ == "__main__":
    basename = split(sys.argv[0])[-1]
    args = sys.argv[1:]
    path = libdirs

    if "--help" in args or not args:
        print >>sys.stderr, """\
Usage: %s [ <options> ] <filename>

Compile the program whose principal file is given in place of <filename>.
The following options may be specified:

-c   Only partially compile the program; do not attempt to build or link it
-g   Generate debugging information for the built executable
-q   Silence messages produced when building an executable
-r   Reset (discard) cached program information; inspect the whole program again
-tb  Provide a traceback for any internal errors (development only)
-v   Report compiler activities in a verbose fashion (development only)

Some options may be followed by values, either immediately after the option
(without any space between) or in the arguments that follow them:

-o   Indicate the output executable name
-W   Show warnings on the topics indicated

Currently, the following warnings are supported:

all     Show all possible warnings

args    Show invocations where a callable may be involved that cannot accept the
        arguments provided
""" % basename
        sys.exit(1)

    # Determine the options and arguments.

    debug = False
    make = True
    make_verbose = True
    reset = False
    traceback = False
    verbose = False
    warnings = []

    filenames = []
    outputs = []

    # Obtain program filenames by default.

    l = filenames
    needed = None

    for arg in args:
        if arg == "-c": make = False
        elif arg == "-g": debug = True
        elif arg == "-q": make_verbose = False
        elif arg == "-r": reset = True
        elif arg == "-tb": traceback = True
        elif arg.startswith("-o"): l, needed = start_arg_list(outputs, arg, "-o", 1)
        elif arg == "-v": verbose = True
        elif arg.startswith("-W"): l, needed = start_arg_list(warnings, arg, "-W", 1)
        else:
            l.append(arg)
            if needed:
                needed -= 1

        if needed == 0:
            l = filenames

    # Obtain the program filename.

    if len(filenames) != 1:
        print >>sys.stderr, "One main program file must be specified."
        sys.exit(1)

    filename = abspath(filenames[0])
    path.append(split(filename)[0])

    # Obtain the output filename.

    if outputs and not make:
        print >>sys.stderr, "Output specified but building disabled."

    output = outputs and outputs[0] or "_main"

    # Define the output data directories.

    datadir = "_lplc"
    cache_dir = join(datadir, "_cache")
    deduced_dir = join(datadir, "_deduced")
    output_dir = join(datadir, "_output")
    generated_dir = join(datadir, "_generated")

    # Load the program.

    try:
        start = now = time()

        i = importer.Importer(path, cache_dir, verbose, warnings)
        m = i.initialise(filename, reset)
        success = i.finalise()

        now = stopwatch("Inspection", now)

        # Check for success, indicating missing references otherwise.

        if not success:
            show_missing(i.missing)
            sys.exit(1)

        d = deducer.Deducer(i, deduced_dir)
        d.to_output()

        now = stopwatch("Deduction", now)

        o = optimiser.Optimiser(i, d, output_dir)
        o.to_output()

        now = stopwatch("Optimisation", now)

        g = generator.Generator(i, o, generated_dir)
        g.to_output(debug)

        now = stopwatch("Generation", now)

        t = translator.Translator(i, d, o, generated_dir)
        t.to_output()

        now = stopwatch("Translation", now)

        # Compile the program unless otherwise indicated.

        if make:
            make_clean_cmd = ["make", "-C", generated_dir, "clean"]
            make_cmd = make_clean_cmd[:-1]

            retval = call(make_clean_cmd, make_verbose)
            if not retval:
                retval = call(make_cmd, make_verbose)

            if not retval:
                stopwatch("Compilation", now)
            else:
                sys.exit(retval)

            # Move the executable into the current directory.

            rename(join(generated_dir, "main"), output)

    # Report any errors.

    except error.SyntaxError, exc:
        show_syntax_error(exc)
        if traceback:
            raise
        sys.exit(1)

    except ProcessingError, exc:
        print exc
        if traceback:
            raise
        sys.exit(1)

    else:
        sys.exit(0)

# vim: tabstop=4 expandtab shiftwidth=4
